---
description: A Beginner's Guide to Token Gating with Lighthouse SDK and a Custom Contract
---

# 📄 Token Gating and Custom Contract

Welcome to this tutorial! If you're looking to control access to content using blockchain tokens and the Lighthouse SDK, you've landed in the right place.

### **📖 What is Token Gating?**

Imagine you have a special VIP event and only people with VIP passes can enter. In the digital world, this "VIP pass" is often a blockchain token. If someone holds this token in their digital wallet, they get access to special content or features. This concept is called **token gating**.

### **📝 The Smart Contract**

Before we use Lighthouse SDK, let's understand the smart contract that's in play. Below is a Solidity contract that maintains a counter and returns **`1`** on every even call and **`0`** otherwise.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CustomContract {
    uint256 private callCounter;

    constructor() {
        callCounter = 0;
    }

    // A function that increments the counter and returns 1 if
    // the counter is even after the increment, 0 otherwise
    function get() public returns (uint256) {
        callCounter = callCounter + 1;
        if (callCounter % 2 == 0) {
            return 1;
        } else {
            return 0;
        }
    }

    // Function to check the current state of the counter (optional)
    function checkCounter() public view returns (uint256) {
        return callCounter;
    }
}
```

Now, with this contract, we can set up token gating using the Lighthouse SDK.

### **🛠️ How Does Lighthouse SDK Help?**

Lighthouse SDK provides tools to simplify interactions with blockchain data. It offers ready-made functions to handle access control based on conditions, such as the return value from our smart contract's **`get`** method.

### **📄 Access Control with Lighthouse SDK**

Lighthouse SDK supports various conditions for access control:

1. **NFTs and Tokens**: Including ERC20, ERC721, and ERC1155 standards.
2. **Custom Contracts**: You can specify conditions based on the output of custom contracts deployed on various blockchains.
3. **Native chain tokens**: Like ETH.
4. **Time-based Access**: Grant or deny access based on specific times or block numbers.

Here's an example condition using a custom contract:

```jsx
{
    id: 1,
    chain: "Mumbai",
    method: "get",
    standardContractType: "Custom",
    contractAddress: "0x019e5A2Eb07C677E0173CA789d1b8ed4384e59A5",
    returnValueTest: {
	    comparator: "==",
	    value: "1"
    },
    parameters: [],
    inputArrayType: [],
    outputType: "uint256"
}
```

This condition checks if the **`get`** method of a custom contract on the Mumbai chain returns a value of **`1`**.

### **💻 Setting up Token Gating using Lighthouse SDK**

#### **Step 1: Set Up Your Node.js Application**

Begin by creating a new Node.js project:

```bash
mkdir lighthouse-access-control-app
cd lighthouse-access-control-app
npm init -y
```

#### **Step 2: Install Necessary Packages**

You'll need **`dotenv`** for environment configurations, **`ethers`** for Ethereum functionalities, and of course, **`@lighthouse-web3/sdk`**:

```bash
npm install dotenv ethers @lighthouse-web3/sdk
```

#### **Step 3: Implement Access Control**

Here's a simple script showcasing how to apply access control using the Lighthouse SDK:

```jsx
import * as dotenv from 'dotenv';
dotenv.config();
import ethers from "ethers";
import lighthouse from '@lighthouse-web3/sdk';

// Function to sign authentication message
const signAuthMessage = async (publicKey, privateKey) => {
    const provider = new ethers.JsonRpcProvider();
    const signer = new ethers.Wallet(privateKey, provider);
    const messageRequested = (await lighthouse.getAuthMessage(publicKey)).data.message;
    const signedMessage = await signer.signMessage(messageRequested);
    return signedMessage;
}

// Apply access control conditions
const accessControl = async () => {
    // CID generated by uploading a file with encryption
    const cid = "Qma7Na9sEdeM6aQeu6bUFW54HktNnW2k8g226VunXBhrn7";
    const publicKey = "0xa3c960b3ba29367ecbcaf1430452c6cd7516f588";
    const privateKey = process.env.PRIVATE_KEY_WALLET1;

    const conditions = [
        {
            id: 1,
            chain: "Optimism",
            method: "getBlockNumber",
            standardContractType: "",
            returnValueTest: {
                comparator: ">=",
                value: "13349"
            },
        },
    ];
    const aggregator = "([1])";

    const signedMessage = await signAuthMessage(publicKey, privateKey);

    const response = await lighthouse.applyAccessCondition(
        publicKey,
        cid,
        signedMessage,
        conditions,
        aggregator
    );

    console.log(response);
}

accessControl();
```

The above implementation will now work in tandem with our **`CustomContract`**. When you call the **`get()`** function of our contract, it will increment a counter. If the counter value becomes even after the increment, it will return **`1`**. The Lighthouse SDK will then use this return value to determine access control based on the conditions you've set.

### **🎉 Wrapping Up**

By combining Ethereum smart contracts with Lighthouse SDK, you can create intricate access control mechanisms to gate your content effectively. This approach offers both the security of the Ethereum blockchain and the flexibility of the Lighthouse SDK. Dive in, experiment, and secure your content in innovative ways!
